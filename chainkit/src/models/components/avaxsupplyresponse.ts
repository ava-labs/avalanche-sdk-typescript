/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type AvaxSupplyResponse = {
  /**
   * The circulating supply of AVAX.
   */
  circulatingSupply: string;
  /**
   * The total supply of AVAX.
   */
  totalSupply: string;
  /**
   * Represents the total amount of AVAX burned on the P-Chain. This value includes AVAX lost when the sum of input UTXOs exceeds the sum of output UTXOs—potentially by more than the expected transaction fee, such as in malformed or improperly constructed transactions—as well as all L1 validator fees that have been burned to date.
   */
  totalPBurned: string;
  /**
   * Represents the total amount of AVAX burned on the C-Chain. This value includes the total amount of AVAX burned on the C-Chain in evm txns and the total amount of AVAX burned on the C-Chain in atomic txns.
   */
  totalCBurned: string;
  /**
   * The total X-chain burned fees of AVAX.
   */
  totalXBurned: string;
  /**
   * The total staked AVAX.
   */
  totalStaked: string;
  /**
   * The total locked AVAX.
   */
  totalLocked: string;
  /**
   * The total rewards AVAX.
   */
  totalRewards: string;
  /**
   * The last updated time of the AVAX supply.
   */
  lastUpdated: Date;
  /**
   * The genesis unlock amount of the AVAX supply.
   */
  genesisUnlock: string;
  /**
   * The total L1 validator fees of AVAX.
   */
  l1ValidatorFees: string;
};

/** @internal */
export const AvaxSupplyResponse$inboundSchema: z.ZodType<
  AvaxSupplyResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  circulatingSupply: z.string(),
  totalSupply: z.string(),
  totalPBurned: z.string(),
  totalCBurned: z.string(),
  totalXBurned: z.string(),
  totalStaked: z.string(),
  totalLocked: z.string(),
  totalRewards: z.string(),
  lastUpdated: z.string().datetime({ offset: true }).transform(v =>
    new Date(v)
  ),
  genesisUnlock: z.string(),
  l1ValidatorFees: z.string(),
});
/** @internal */
export type AvaxSupplyResponse$Outbound = {
  circulatingSupply: string;
  totalSupply: string;
  totalPBurned: string;
  totalCBurned: string;
  totalXBurned: string;
  totalStaked: string;
  totalLocked: string;
  totalRewards: string;
  lastUpdated: string;
  genesisUnlock: string;
  l1ValidatorFees: string;
};

/** @internal */
export const AvaxSupplyResponse$outboundSchema: z.ZodType<
  AvaxSupplyResponse$Outbound,
  z.ZodTypeDef,
  AvaxSupplyResponse
> = z.object({
  circulatingSupply: z.string(),
  totalSupply: z.string(),
  totalPBurned: z.string(),
  totalCBurned: z.string(),
  totalXBurned: z.string(),
  totalStaked: z.string(),
  totalLocked: z.string(),
  totalRewards: z.string(),
  lastUpdated: z.date().transform(v => v.toISOString()),
  genesisUnlock: z.string(),
  l1ValidatorFees: z.string(),
});

export function avaxSupplyResponseToJSON(
  avaxSupplyResponse: AvaxSupplyResponse,
): string {
  return JSON.stringify(
    AvaxSupplyResponse$outboundSchema.parse(avaxSupplyResponse),
  );
}
export function avaxSupplyResponseFromJSON(
  jsonString: string,
): SafeParseResult<AvaxSupplyResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AvaxSupplyResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AvaxSupplyResponse' from JSON`,
  );
}
