// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type ListXChainTransactionsResponseTransactionType string

const (
	ListXChainTransactionsResponseTransactionTypeXChainNonLinearTransaction ListXChainTransactionsResponseTransactionType = "XChainNonLinearTransaction"
	ListXChainTransactionsResponseTransactionTypeXChainLinearTransaction    ListXChainTransactionsResponseTransactionType = "XChainLinearTransaction"
)

type ListXChainTransactionsResponseTransaction struct {
	XChainNonLinearTransaction *XChainNonLinearTransaction `queryParam:"inline"`
	XChainLinearTransaction    *XChainLinearTransaction    `queryParam:"inline"`

	Type ListXChainTransactionsResponseTransactionType
}

func CreateListXChainTransactionsResponseTransactionXChainNonLinearTransaction(xChainNonLinearTransaction XChainNonLinearTransaction) ListXChainTransactionsResponseTransaction {
	typ := ListXChainTransactionsResponseTransactionTypeXChainNonLinearTransaction

	return ListXChainTransactionsResponseTransaction{
		XChainNonLinearTransaction: &xChainNonLinearTransaction,
		Type:                       typ,
	}
}

func CreateListXChainTransactionsResponseTransactionXChainLinearTransaction(xChainLinearTransaction XChainLinearTransaction) ListXChainTransactionsResponseTransaction {
	typ := ListXChainTransactionsResponseTransactionTypeXChainLinearTransaction

	return ListXChainTransactionsResponseTransaction{
		XChainLinearTransaction: &xChainLinearTransaction,
		Type:                    typ,
	}
}

func (u *ListXChainTransactionsResponseTransaction) UnmarshalJSON(data []byte) error {

	var xChainNonLinearTransaction XChainNonLinearTransaction = XChainNonLinearTransaction{}
	if err := utils.UnmarshalJSON(data, &xChainNonLinearTransaction, "", true, true); err == nil {
		u.XChainNonLinearTransaction = &xChainNonLinearTransaction
		u.Type = ListXChainTransactionsResponseTransactionTypeXChainNonLinearTransaction
		return nil
	}

	var xChainLinearTransaction XChainLinearTransaction = XChainLinearTransaction{}
	if err := utils.UnmarshalJSON(data, &xChainLinearTransaction, "", true, true); err == nil {
		u.XChainLinearTransaction = &xChainLinearTransaction
		u.Type = ListXChainTransactionsResponseTransactionTypeXChainLinearTransaction
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListXChainTransactionsResponseTransaction", string(data))
}

func (u ListXChainTransactionsResponseTransaction) MarshalJSON() ([]byte, error) {
	if u.XChainNonLinearTransaction != nil {
		return utils.MarshalJSON(u.XChainNonLinearTransaction, "", true)
	}

	if u.XChainLinearTransaction != nil {
		return utils.MarshalJSON(u.XChainLinearTransaction, "", true)
	}

	return nil, errors.New("could not marshal union type ListXChainTransactionsResponseTransaction: all fields are null")
}

type ListXChainTransactionsResponse struct {
	// A token, which can be sent as `pageToken` to retrieve the next page. If this field is omitted or empty, there are no subsequent pages.
	NextPageToken *string                                     `json:"nextPageToken,omitempty"`
	Transactions  []ListXChainTransactionsResponseTransaction `json:"transactions"`
	ChainInfo     PrimaryNetworkChainInfo                     `json:"chainInfo"`
}

func (o *ListXChainTransactionsResponse) GetNextPageToken() *string {
	if o == nil {
		return nil
	}
	return o.NextPageToken
}

func (o *ListXChainTransactionsResponse) GetTransactions() []ListXChainTransactionsResponseTransaction {
	if o == nil {
		return []ListXChainTransactionsResponseTransaction{}
	}
	return o.Transactions
}

func (o *ListXChainTransactionsResponse) GetChainInfo() PrimaryNetworkChainInfo {
	if o == nil {
		return PrimaryNetworkChainInfo{}
	}
	return o.ChainInfo
}
