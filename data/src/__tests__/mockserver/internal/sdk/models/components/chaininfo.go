// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

type ChainInfoEnabledFeature string

const (
	ChainInfoEnabledFeatureNftIndexing ChainInfoEnabledFeature = "nftIndexing"
	ChainInfoEnabledFeatureWebhooks    ChainInfoEnabledFeature = "webhooks"
	ChainInfoEnabledFeatureTeleporter  ChainInfoEnabledFeature = "teleporter"
)

func (e ChainInfoEnabledFeature) ToPointer() *ChainInfoEnabledFeature {
	return &e
}
func (e *ChainInfoEnabledFeature) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "nftIndexing":
		fallthrough
	case "webhooks":
		fallthrough
	case "teleporter":
		*e = ChainInfoEnabledFeature(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ChainInfoEnabledFeature: %v", v)
	}
}

type ChainInfo struct {
	ChainID string `json:"chainId"`
	// Status of chain nodes. Chain nodes can become temporarily `UNAVAILABLE` for several reasons, such as validator stake falling below threshold. If chain nodes are `UNAVAILABLE`, requests that rely on data from the chain nodes may return 503 errors.
	Status           ChainStatus               `json:"status"`
	ChainName        string                    `json:"chainName"`
	Description      string                    `json:"description"`
	PlatformChainID  *string                   `json:"platformChainId,omitempty"`
	SubnetID         *string                   `json:"subnetId,omitempty"`
	VMID             *string                   `json:"vmId,omitempty"`
	VMName           VMName                    `json:"vmName"`
	ExplorerURL      *string                   `json:"explorerUrl,omitempty"`
	RPCURL           string                    `json:"rpcUrl"`
	WsURL            *string                   `json:"wsUrl,omitempty"`
	IsTestnet        bool                      `json:"isTestnet"`
	UtilityAddresses *UtilityAddresses         `json:"utilityAddresses,omitempty"`
	NetworkToken     NetworkToken              `json:"networkToken"`
	ChainLogoURI     *string                   `json:"chainLogoUri,omitempty"`
	Private          *bool                     `json:"private,omitempty"`
	EnabledFeatures  []ChainInfoEnabledFeature `json:"enabledFeatures,omitempty"`
}

func (o *ChainInfo) GetChainID() string {
	if o == nil {
		return ""
	}
	return o.ChainID
}

func (o *ChainInfo) GetStatus() ChainStatus {
	if o == nil {
		return ChainStatus("")
	}
	return o.Status
}

func (o *ChainInfo) GetChainName() string {
	if o == nil {
		return ""
	}
	return o.ChainName
}

func (o *ChainInfo) GetDescription() string {
	if o == nil {
		return ""
	}
	return o.Description
}

func (o *ChainInfo) GetPlatformChainID() *string {
	if o == nil {
		return nil
	}
	return o.PlatformChainID
}

func (o *ChainInfo) GetSubnetID() *string {
	if o == nil {
		return nil
	}
	return o.SubnetID
}

func (o *ChainInfo) GetVMID() *string {
	if o == nil {
		return nil
	}
	return o.VMID
}

func (o *ChainInfo) GetVMName() VMName {
	if o == nil {
		return VMName("")
	}
	return o.VMName
}

func (o *ChainInfo) GetExplorerURL() *string {
	if o == nil {
		return nil
	}
	return o.ExplorerURL
}

func (o *ChainInfo) GetRPCURL() string {
	if o == nil {
		return ""
	}
	return o.RPCURL
}

func (o *ChainInfo) GetWsURL() *string {
	if o == nil {
		return nil
	}
	return o.WsURL
}

func (o *ChainInfo) GetIsTestnet() bool {
	if o == nil {
		return false
	}
	return o.IsTestnet
}

func (o *ChainInfo) GetUtilityAddresses() *UtilityAddresses {
	if o == nil {
		return nil
	}
	return o.UtilityAddresses
}

func (o *ChainInfo) GetNetworkToken() NetworkToken {
	if o == nil {
		return NetworkToken{}
	}
	return o.NetworkToken
}

func (o *ChainInfo) GetChainLogoURI() *string {
	if o == nil {
		return nil
	}
	return o.ChainLogoURI
}

func (o *ChainInfo) GetPrivate() *bool {
	if o == nil {
		return nil
	}
	return o.Private
}

func (o *ChainInfo) GetEnabledFeatures() []ChainInfoEnabledFeature {
	if o == nil {
		return nil
	}
	return o.EnabledFeatures
}
