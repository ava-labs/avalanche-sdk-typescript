// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type ContractType string

const (
	ContractTypeErc721  ContractType = "ERC-721"
	ContractTypeErc1155 ContractType = "ERC-1155"
	ContractTypeErc20   ContractType = "ERC-20"
	ContractTypeUnknown ContractType = "UNKNOWN"
)

type Contract struct {
	Erc721Contract  *Erc721Contract  `queryParam:"inline"`
	Erc1155Contract *Erc1155Contract `queryParam:"inline"`
	Erc20Contract   *Erc20Contract   `queryParam:"inline"`
	UnknownContract *UnknownContract `queryParam:"inline"`

	Type ContractType
}

func CreateContractErc721(erc721 Erc721Contract) Contract {
	typ := ContractTypeErc721

	typStr := Erc721ContractErcType(typ)
	erc721.ErcType = typStr

	return Contract{
		Erc721Contract: &erc721,
		Type:           typ,
	}
}

func CreateContractErc1155(erc1155 Erc1155Contract) Contract {
	typ := ContractTypeErc1155

	typStr := Erc1155ContractErcType(typ)
	erc1155.ErcType = typStr

	return Contract{
		Erc1155Contract: &erc1155,
		Type:            typ,
	}
}

func CreateContractErc20(erc20 Erc20Contract) Contract {
	typ := ContractTypeErc20

	typStr := Erc20ContractErcType(typ)
	erc20.ErcType = typStr

	return Contract{
		Erc20Contract: &erc20,
		Type:          typ,
	}
}

func CreateContractUnknown(unknown UnknownContract) Contract {
	typ := ContractTypeUnknown

	typStr := UnknownContractErcType(typ)
	unknown.ErcType = typStr

	return Contract{
		UnknownContract: &unknown,
		Type:            typ,
	}
}

func (u *Contract) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		ErcType string `json:"ercType"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.ErcType {
	case "ERC-721":
		erc721Contract := new(Erc721Contract)
		if err := utils.UnmarshalJSON(data, &erc721Contract, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ErcType == ERC-721) type Erc721Contract within Contract: %w", string(data), err)
		}

		u.Erc721Contract = erc721Contract
		u.Type = ContractTypeErc721
		return nil
	case "ERC-1155":
		erc1155Contract := new(Erc1155Contract)
		if err := utils.UnmarshalJSON(data, &erc1155Contract, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ErcType == ERC-1155) type Erc1155Contract within Contract: %w", string(data), err)
		}

		u.Erc1155Contract = erc1155Contract
		u.Type = ContractTypeErc1155
		return nil
	case "ERC-20":
		erc20Contract := new(Erc20Contract)
		if err := utils.UnmarshalJSON(data, &erc20Contract, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ErcType == ERC-20) type Erc20Contract within Contract: %w", string(data), err)
		}

		u.Erc20Contract = erc20Contract
		u.Type = ContractTypeErc20
		return nil
	case "UNKNOWN":
		unknownContract := new(UnknownContract)
		if err := utils.UnmarshalJSON(data, &unknownContract, "", true, false); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (ErcType == UNKNOWN) type UnknownContract within Contract: %w", string(data), err)
		}

		u.UnknownContract = unknownContract
		u.Type = ContractTypeUnknown
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Contract", string(data))
}

func (u Contract) MarshalJSON() ([]byte, error) {
	if u.Erc721Contract != nil {
		return utils.MarshalJSON(u.Erc721Contract, "", true)
	}

	if u.Erc1155Contract != nil {
		return utils.MarshalJSON(u.Erc1155Contract, "", true)
	}

	if u.Erc20Contract != nil {
		return utils.MarshalJSON(u.Erc20Contract, "", true)
	}

	if u.UnknownContract != nil {
		return utils.MarshalJSON(u.UnknownContract, "", true)
	}

	return nil, errors.New("could not marshal union type Contract: all fields are null")
}

type ListContractsResponse struct {
	// A token, which can be sent as `pageToken` to retrieve the next page. If this field is omitted or empty, there are no subsequent pages.
	NextPageToken *string    `json:"nextPageToken,omitempty"`
	Contracts     []Contract `json:"contracts"`
}

func (o *ListContractsResponse) GetNextPageToken() *string {
	if o == nil {
		return nil
	}
	return o.NextPageToken
}

func (o *ListContractsResponse) GetContracts() []Contract {
	if o == nil {
		return []Contract{}
	}
	return o.Contracts
}
