// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type ListCChainAtomicTransactionsResponseTransactionType string

const (
	ListCChainAtomicTransactionsResponseTransactionTypeCChainExportTransaction ListCChainAtomicTransactionsResponseTransactionType = "CChainExportTransaction"
	ListCChainAtomicTransactionsResponseTransactionTypeCChainImportTransaction ListCChainAtomicTransactionsResponseTransactionType = "CChainImportTransaction"
)

type ListCChainAtomicTransactionsResponseTransaction struct {
	CChainExportTransaction *CChainExportTransaction `queryParam:"inline"`
	CChainImportTransaction *CChainImportTransaction `queryParam:"inline"`

	Type ListCChainAtomicTransactionsResponseTransactionType
}

func CreateListCChainAtomicTransactionsResponseTransactionCChainExportTransaction(cChainExportTransaction CChainExportTransaction) ListCChainAtomicTransactionsResponseTransaction {
	typ := ListCChainAtomicTransactionsResponseTransactionTypeCChainExportTransaction

	return ListCChainAtomicTransactionsResponseTransaction{
		CChainExportTransaction: &cChainExportTransaction,
		Type:                    typ,
	}
}

func CreateListCChainAtomicTransactionsResponseTransactionCChainImportTransaction(cChainImportTransaction CChainImportTransaction) ListCChainAtomicTransactionsResponseTransaction {
	typ := ListCChainAtomicTransactionsResponseTransactionTypeCChainImportTransaction

	return ListCChainAtomicTransactionsResponseTransaction{
		CChainImportTransaction: &cChainImportTransaction,
		Type:                    typ,
	}
}

func (u *ListCChainAtomicTransactionsResponseTransaction) UnmarshalJSON(data []byte) error {

	var cChainExportTransaction CChainExportTransaction = CChainExportTransaction{}
	if err := utils.UnmarshalJSON(data, &cChainExportTransaction, "", true, true); err == nil {
		u.CChainExportTransaction = &cChainExportTransaction
		u.Type = ListCChainAtomicTransactionsResponseTransactionTypeCChainExportTransaction
		return nil
	}

	var cChainImportTransaction CChainImportTransaction = CChainImportTransaction{}
	if err := utils.UnmarshalJSON(data, &cChainImportTransaction, "", true, true); err == nil {
		u.CChainImportTransaction = &cChainImportTransaction
		u.Type = ListCChainAtomicTransactionsResponseTransactionTypeCChainImportTransaction
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListCChainAtomicTransactionsResponseTransaction", string(data))
}

func (u ListCChainAtomicTransactionsResponseTransaction) MarshalJSON() ([]byte, error) {
	if u.CChainExportTransaction != nil {
		return utils.MarshalJSON(u.CChainExportTransaction, "", true)
	}

	if u.CChainImportTransaction != nil {
		return utils.MarshalJSON(u.CChainImportTransaction, "", true)
	}

	return nil, errors.New("could not marshal union type ListCChainAtomicTransactionsResponseTransaction: all fields are null")
}

type ListCChainAtomicTransactionsResponse struct {
	// A token, which can be sent as `pageToken` to retrieve the next page. If this field is omitted or empty, there are no subsequent pages.
	NextPageToken *string                                           `json:"nextPageToken,omitempty"`
	Transactions  []ListCChainAtomicTransactionsResponseTransaction `json:"transactions"`
	ChainInfo     PrimaryNetworkChainInfo                           `json:"chainInfo"`
}

func (o *ListCChainAtomicTransactionsResponse) GetNextPageToken() *string {
	if o == nil {
		return nil
	}
	return o.NextPageToken
}

func (o *ListCChainAtomicTransactionsResponse) GetTransactions() []ListCChainAtomicTransactionsResponseTransaction {
	if o == nil {
		return []ListCChainAtomicTransactionsResponseTransaction{}
	}
	return o.Transactions
}

func (o *ListCChainAtomicTransactionsResponse) GetChainInfo() PrimaryNetworkChainInfo {
	if o == nil {
		return PrimaryNetworkChainInfo{}
	}
	return o.ChainInfo
}
